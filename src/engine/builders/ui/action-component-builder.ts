import { Project, SourceFile } from 'ts-morph';
import { UiBaseBuilder } from './ui-base-builder.js';
import { type FileDefinition, type ModuleConfig, type ParsedStatement } from '../../types.js';
import { Reconciler } from '../../reconciler.js';
import { toKebabCase, toPascalCase } from '../../../utils/string.js';
import { ts } from '../../primitives/statements/factory.js';

export class ActionComponentBuilder extends UiBaseBuilder {
  constructor(
    protected moduleName: string,
    protected config: ModuleConfig,
  ) {
    super(moduleName, config);
  }

  async build(project: Project, sourceFile: SourceFile | undefined): Promise<void> {
    this.loadUiConfig();
    const routes = this.resolveRoutes();
    if (!routes || routes.length === 0) return;

    for (const route of routes) {
      // Only generate generic components for actions, mostly mutations (POST/PUT/DELETE/PATCH) or GET with explicit action intent
      // Actually, usually buttons imply mutation or side-effect.
      // But let's support all custom routes.
      if (!(route as Record<string, unknown>)['action']) continue;

      const actionName = (route as Record<string, unknown>)['action'] as string;
      const componentName = `${toPascalCase(actionName)}Button`;
      const fileName = `src/components/actions/${componentName}.tsx`;

      const file = project.createSourceFile(fileName, '', { overwrite: true });

      const hookName = `use${toPascalCase(actionName)}`;
      const hookFile = `use-${toKebabCase(actionName)}`;

      const definition: FileDefinition = {
        header: this.getHeader(),
        imports: [
          {
            moduleSpecifier: 'react',
            namedImports: ['useState'],
          },
          {
            moduleSpecifier: `@/hooks/${hookFile}`,
            namedImports: [hookName],
          },
        ],
        variables: [
          {
            name: componentName,
            isExported: true,
            declarationKind: 'const',
            initializer: this.generateComponent(route, hookName),
          },
        ],
      };

      Reconciler.reconcile(file, definition);
    }
  }

  private generateComponent(route: unknown, hookName: string): ParsedStatement {
    const action = (route as Record<string, unknown>)['action'] as string;
    const label = toPascalCase(action)
      .replace(/([A-Z])/g, ' $1')
      .trim();

    return ts`({ id, initialData, onSuccess, className }: { id?: string, initialData?: unknown, onSuccess?: () => void, className?: string }) => {
    const mutation = ${hookName}();
    
    const onClick = () => {
        // Assume id is passed or data
        // If route requires data, we might need a modal or separate form.
        // For simple button, assume no data or only ID.
        // We pass 'initialData' or { id } as payload.
        const payload = id ? { id, ...initialData } : initialData;
        mutation.mutate(payload, { onSuccess });
    };

    return (
        <button
            onClick={onClick}
            disabled={mutation.isPending}
            className={className || "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"}
        >
            {mutation.isPending ? 'Processing...' : '${label}'}
        </button>
    );
}`;
  }

  private getHeader(): string {
    return '// GENERATED CODE - DO NOT MODIFY\n// This file was generated by the ActionComponentBuilder.';
  }
}
